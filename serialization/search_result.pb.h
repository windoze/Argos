// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: search_result.proto

#ifndef PROTOBUF_search_5fresult_2eproto__INCLUDED
#define PROTOBUF_search_5fresult_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_search_5fresult_2eproto();
void protobuf_AssignDesc_search_5fresult_2eproto();
void protobuf_ShutdownFile_search_5fresult_2eproto();

class SearchResult;
class Histo;
class Histo_Pair;
class GeoLoc;
class Value;
class Document;

enum SearchResult_Status {
  SearchResult_Status_STATUS_OK = 0,
  SearchResult_Status_STATUS_ERR = 1
};
bool SearchResult_Status_IsValid(int value);
const SearchResult_Status SearchResult_Status_Status_MIN = SearchResult_Status_STATUS_OK;
const SearchResult_Status SearchResult_Status_Status_MAX = SearchResult_Status_STATUS_ERR;
const int SearchResult_Status_Status_ARRAYSIZE = SearchResult_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* SearchResult_Status_descriptor();
inline const ::std::string& SearchResult_Status_Name(SearchResult_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    SearchResult_Status_descriptor(), value);
}
inline bool SearchResult_Status_Parse(
    const ::std::string& name, SearchResult_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SearchResult_Status>(
    SearchResult_Status_descriptor(), name, value);
}
enum Value_Type {
  Value_Type_EMPTY = 0,
  Value_Type_STRING = 1,
  Value_Type_INT = 2,
  Value_Type_DOUBLE = 3,
  Value_Type_GEOLOC = 4,
  Value_Type_INTARR = 5,
  Value_Type_DOUBLEARR = 6,
  Value_Type_GEOLOCARR = 7
};
bool Value_Type_IsValid(int value);
const Value_Type Value_Type_Type_MIN = Value_Type_EMPTY;
const Value_Type Value_Type_Type_MAX = Value_Type_GEOLOCARR;
const int Value_Type_Type_ARRAYSIZE = Value_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Value_Type_descriptor();
inline const ::std::string& Value_Type_Name(Value_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Value_Type_descriptor(), value);
}
inline bool Value_Type_Parse(
    const ::std::string& name, Value_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Value_Type>(
    Value_Type_descriptor(), name, value);
}
// ===================================================================

class SearchResult : public ::google::protobuf::Message {
 public:
  SearchResult();
  virtual ~SearchResult();
  
  SearchResult(const SearchResult& from);
  
  inline SearchResult& operator=(const SearchResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchResult& default_instance();
  
  void Swap(SearchResult* other);
  
  // implements Message ----------------------------------------------
  
  SearchResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchResult& from);
  void MergeFrom(const SearchResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef SearchResult_Status Status;
  static const Status STATUS_OK = SearchResult_Status_STATUS_OK;
  static const Status STATUS_ERR = SearchResult_Status_STATUS_ERR;
  static inline bool Status_IsValid(int value) {
    return SearchResult_Status_IsValid(value);
  }
  static const Status Status_MIN =
    SearchResult_Status_Status_MIN;
  static const Status Status_MAX =
    SearchResult_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    SearchResult_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return SearchResult_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return SearchResult_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return SearchResult_Status_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .pb.SearchResult.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::pb::SearchResult_Status status() const;
  inline void set_status(::pb::SearchResult_Status value);
  
  // optional int32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::int32 total() const;
  inline void set_total(::google::protobuf::int32 value);
  
  // optional int32 returned = 3;
  inline bool has_returned() const;
  inline void clear_returned();
  static const int kReturnedFieldNumber = 3;
  inline ::google::protobuf::int32 returned() const;
  inline void set_returned(::google::protobuf::int32 value);
  
  // optional int32 time_used = 4;
  inline bool has_time_used() const;
  inline void clear_time_used();
  static const int kTimeUsedFieldNumber = 4;
  inline ::google::protobuf::int32 time_used() const;
  inline void set_time_used(::google::protobuf::int32 value);
  
  // repeated .pb.Histo histos = 5;
  inline int histos_size() const;
  inline void clear_histos();
  static const int kHistosFieldNumber = 5;
  inline const ::pb::Histo& histos(int index) const;
  inline ::pb::Histo* mutable_histos(int index);
  inline ::pb::Histo* add_histos();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Histo >&
      histos() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Histo >*
      mutable_histos();
  
  // repeated string fields = 6;
  inline int fields_size() const;
  inline void clear_fields();
  static const int kFieldsFieldNumber = 6;
  inline const ::std::string& fields(int index) const;
  inline ::std::string* mutable_fields(int index);
  inline void set_fields(int index, const ::std::string& value);
  inline void set_fields(int index, const char* value);
  inline void set_fields(int index, const char* value, size_t size);
  inline ::std::string* add_fields();
  inline void add_fields(const ::std::string& value);
  inline void add_fields(const char* value);
  inline void add_fields(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();
  
  // repeated .pb.Document documents = 7;
  inline int documents_size() const;
  inline void clear_documents();
  static const int kDocumentsFieldNumber = 7;
  inline const ::pb::Document& documents(int index) const;
  inline ::pb::Document* mutable_documents(int index);
  inline ::pb::Document* add_documents();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Document >&
      documents() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Document >*
      mutable_documents();
  
  // @@protoc_insertion_point(class_scope:pb.SearchResult)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_returned();
  inline void clear_has_returned();
  inline void set_has_time_used();
  inline void clear_has_time_used();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int status_;
  ::google::protobuf::int32 total_;
  ::google::protobuf::int32 returned_;
  ::google::protobuf::int32 time_used_;
  ::google::protobuf::RepeatedPtrField< ::pb::Histo > histos_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  ::google::protobuf::RepeatedPtrField< ::pb::Document > documents_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_search_5fresult_2eproto();
  friend void protobuf_AssignDesc_search_5fresult_2eproto();
  friend void protobuf_ShutdownFile_search_5fresult_2eproto();
  
  void InitAsDefaultInstance();
  static SearchResult* default_instance_;
};
// -------------------------------------------------------------------

class Histo_Pair : public ::google::protobuf::Message {
 public:
  Histo_Pair();
  virtual ~Histo_Pair();
  
  Histo_Pair(const Histo_Pair& from);
  
  inline Histo_Pair& operator=(const Histo_Pair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Histo_Pair& default_instance();
  
  void Swap(Histo_Pair* other);
  
  // implements Message ----------------------------------------------
  
  Histo_Pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Histo_Pair& from);
  void MergeFrom(const Histo_Pair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .pb.Value key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::pb::Value& key() const;
  inline ::pb::Value* mutable_key();
  inline ::pb::Value* release_key();
  
  // required int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pb.Histo.Pair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pb::Value* key_;
  ::google::protobuf::int32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_search_5fresult_2eproto();
  friend void protobuf_AssignDesc_search_5fresult_2eproto();
  friend void protobuf_ShutdownFile_search_5fresult_2eproto();
  
  void InitAsDefaultInstance();
  static Histo_Pair* default_instance_;
};
// -------------------------------------------------------------------

class Histo : public ::google::protobuf::Message {
 public:
  Histo();
  virtual ~Histo();
  
  Histo(const Histo& from);
  
  inline Histo& operator=(const Histo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Histo& default_instance();
  
  void Swap(Histo* other);
  
  // implements Message ----------------------------------------------
  
  Histo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Histo& from);
  void MergeFrom(const Histo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Histo_Pair Pair;
  
  // accessors -------------------------------------------------------
  
  // required string field = 1;
  inline bool has_field() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 1;
  inline const ::std::string& field() const;
  inline void set_field(const ::std::string& value);
  inline void set_field(const char* value);
  inline void set_field(const char* value, size_t size);
  inline ::std::string* mutable_field();
  inline ::std::string* release_field();
  
  // required int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // repeated .pb.Histo.Pair pairs = 3;
  inline int pairs_size() const;
  inline void clear_pairs();
  static const int kPairsFieldNumber = 3;
  inline const ::pb::Histo_Pair& pairs(int index) const;
  inline ::pb::Histo_Pair* mutable_pairs(int index);
  inline ::pb::Histo_Pair* add_pairs();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Histo_Pair >&
      pairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Histo_Pair >*
      mutable_pairs();
  
  // @@protoc_insertion_point(class_scope:pb.Histo)
 private:
  inline void set_has_field();
  inline void clear_has_field();
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* field_;
  ::google::protobuf::RepeatedPtrField< ::pb::Histo_Pair > pairs_;
  ::google::protobuf::int32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_search_5fresult_2eproto();
  friend void protobuf_AssignDesc_search_5fresult_2eproto();
  friend void protobuf_ShutdownFile_search_5fresult_2eproto();
  
  void InitAsDefaultInstance();
  static Histo* default_instance_;
};
// -------------------------------------------------------------------

class GeoLoc : public ::google::protobuf::Message {
 public:
  GeoLoc();
  virtual ~GeoLoc();
  
  GeoLoc(const GeoLoc& from);
  
  inline GeoLoc& operator=(const GeoLoc& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GeoLoc& default_instance();
  
  void Swap(GeoLoc* other);
  
  // implements Message ----------------------------------------------
  
  GeoLoc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeoLoc& from);
  void MergeFrom(const GeoLoc& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float lng = 1;
  inline bool has_lng() const;
  inline void clear_lng();
  static const int kLngFieldNumber = 1;
  inline float lng() const;
  inline void set_lng(float value);
  
  // required float lat = 2;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 2;
  inline float lat() const;
  inline void set_lat(float value);
  
  // @@protoc_insertion_point(class_scope:pb.GeoLoc)
 private:
  inline void set_has_lng();
  inline void clear_has_lng();
  inline void set_has_lat();
  inline void clear_has_lat();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float lng_;
  float lat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_search_5fresult_2eproto();
  friend void protobuf_AssignDesc_search_5fresult_2eproto();
  friend void protobuf_ShutdownFile_search_5fresult_2eproto();
  
  void InitAsDefaultInstance();
  static GeoLoc* default_instance_;
};
// -------------------------------------------------------------------

class Value : public ::google::protobuf::Message {
 public:
  Value();
  virtual ~Value();
  
  Value(const Value& from);
  
  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value& default_instance();
  
  void Swap(Value* other);
  
  // implements Message ----------------------------------------------
  
  Value* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Value_Type Type;
  static const Type EMPTY = Value_Type_EMPTY;
  static const Type STRING = Value_Type_STRING;
  static const Type INT = Value_Type_INT;
  static const Type DOUBLE = Value_Type_DOUBLE;
  static const Type GEOLOC = Value_Type_GEOLOC;
  static const Type INTARR = Value_Type_INTARR;
  static const Type DOUBLEARR = Value_Type_DOUBLEARR;
  static const Type GEOLOCARR = Value_Type_GEOLOCARR;
  static inline bool Type_IsValid(int value) {
    return Value_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Value_Type_Type_MIN;
  static const Type Type_MAX =
    Value_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Value_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Value_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Value_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Value_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .pb.Value.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pb::Value_Type type() const;
  inline void set_type(::pb::Value_Type value);
  
  // optional string svalue = 2;
  inline bool has_svalue() const;
  inline void clear_svalue();
  static const int kSvalueFieldNumber = 2;
  inline const ::std::string& svalue() const;
  inline void set_svalue(const ::std::string& value);
  inline void set_svalue(const char* value);
  inline void set_svalue(const char* value, size_t size);
  inline ::std::string* mutable_svalue();
  inline ::std::string* release_svalue();
  
  // optional int64 ivalue = 3;
  inline bool has_ivalue() const;
  inline void clear_ivalue();
  static const int kIvalueFieldNumber = 3;
  inline ::google::protobuf::int64 ivalue() const;
  inline void set_ivalue(::google::protobuf::int64 value);
  
  // optional double dvalue = 4;
  inline bool has_dvalue() const;
  inline void clear_dvalue();
  static const int kDvalueFieldNumber = 4;
  inline double dvalue() const;
  inline void set_dvalue(double value);
  
  // optional .pb.GeoLoc geoloc = 5;
  inline bool has_geoloc() const;
  inline void clear_geoloc();
  static const int kGeolocFieldNumber = 5;
  inline const ::pb::GeoLoc& geoloc() const;
  inline ::pb::GeoLoc* mutable_geoloc();
  inline ::pb::GeoLoc* release_geoloc();
  
  // repeated int64 ivalues = 6;
  inline int ivalues_size() const;
  inline void clear_ivalues();
  static const int kIvaluesFieldNumber = 6;
  inline ::google::protobuf::int64 ivalues(int index) const;
  inline void set_ivalues(int index, ::google::protobuf::int64 value);
  inline void add_ivalues(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      ivalues() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_ivalues();
  
  // repeated double dvalues = 7;
  inline int dvalues_size() const;
  inline void clear_dvalues();
  static const int kDvaluesFieldNumber = 7;
  inline double dvalues(int index) const;
  inline void set_dvalues(int index, double value);
  inline void add_dvalues(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      dvalues() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_dvalues();
  
  // repeated .pb.GeoLoc geolocs = 8;
  inline int geolocs_size() const;
  inline void clear_geolocs();
  static const int kGeolocsFieldNumber = 8;
  inline const ::pb::GeoLoc& geolocs(int index) const;
  inline ::pb::GeoLoc* mutable_geolocs(int index);
  inline ::pb::GeoLoc* add_geolocs();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::GeoLoc >&
      geolocs() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::GeoLoc >*
      mutable_geolocs();
  
  // @@protoc_insertion_point(class_scope:pb.Value)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_svalue();
  inline void clear_has_svalue();
  inline void set_has_ivalue();
  inline void clear_has_ivalue();
  inline void set_has_dvalue();
  inline void clear_has_dvalue();
  inline void set_has_geoloc();
  inline void clear_has_geoloc();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* svalue_;
  ::google::protobuf::int64 ivalue_;
  double dvalue_;
  ::pb::GeoLoc* geoloc_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > ivalues_;
  ::google::protobuf::RepeatedField< double > dvalues_;
  ::google::protobuf::RepeatedPtrField< ::pb::GeoLoc > geolocs_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_search_5fresult_2eproto();
  friend void protobuf_AssignDesc_search_5fresult_2eproto();
  friend void protobuf_ShutdownFile_search_5fresult_2eproto();
  
  void InitAsDefaultInstance();
  static Value* default_instance_;
};
// -------------------------------------------------------------------

class Document : public ::google::protobuf::Message {
 public:
  Document();
  virtual ~Document();
  
  Document(const Document& from);
  
  inline Document& operator=(const Document& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Document& default_instance();
  
  void Swap(Document* other);
  
  // implements Message ----------------------------------------------
  
  Document* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Document& from);
  void MergeFrom(const Document& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .pb.Value values = 1;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 1;
  inline const ::pb::Value& values(int index) const;
  inline ::pb::Value* mutable_values(int index);
  inline ::pb::Value* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Value >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Value >*
      mutable_values();
  
  // @@protoc_insertion_point(class_scope:pb.Document)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::pb::Value > values_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_search_5fresult_2eproto();
  friend void protobuf_AssignDesc_search_5fresult_2eproto();
  friend void protobuf_ShutdownFile_search_5fresult_2eproto();
  
  void InitAsDefaultInstance();
  static Document* default_instance_;
};
// ===================================================================


// ===================================================================

// SearchResult

// required .pb.SearchResult.Status status = 1;
inline bool SearchResult::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchResult::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchResult::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchResult::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::pb::SearchResult_Status SearchResult::status() const {
  return static_cast< ::pb::SearchResult_Status >(status_);
}
inline void SearchResult::set_status(::pb::SearchResult_Status value) {
  GOOGLE_DCHECK(::pb::SearchResult_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional int32 total = 2;
inline bool SearchResult::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchResult::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchResult::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchResult::clear_total() {
  total_ = 0;
  clear_has_total();
}
inline ::google::protobuf::int32 SearchResult::total() const {
  return total_;
}
inline void SearchResult::set_total(::google::protobuf::int32 value) {
  set_has_total();
  total_ = value;
}

// optional int32 returned = 3;
inline bool SearchResult::has_returned() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchResult::set_has_returned() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchResult::clear_has_returned() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchResult::clear_returned() {
  returned_ = 0;
  clear_has_returned();
}
inline ::google::protobuf::int32 SearchResult::returned() const {
  return returned_;
}
inline void SearchResult::set_returned(::google::protobuf::int32 value) {
  set_has_returned();
  returned_ = value;
}

// optional int32 time_used = 4;
inline bool SearchResult::has_time_used() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SearchResult::set_has_time_used() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SearchResult::clear_has_time_used() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SearchResult::clear_time_used() {
  time_used_ = 0;
  clear_has_time_used();
}
inline ::google::protobuf::int32 SearchResult::time_used() const {
  return time_used_;
}
inline void SearchResult::set_time_used(::google::protobuf::int32 value) {
  set_has_time_used();
  time_used_ = value;
}

// repeated .pb.Histo histos = 5;
inline int SearchResult::histos_size() const {
  return histos_.size();
}
inline void SearchResult::clear_histos() {
  histos_.Clear();
}
inline const ::pb::Histo& SearchResult::histos(int index) const {
  return histos_.Get(index);
}
inline ::pb::Histo* SearchResult::mutable_histos(int index) {
  return histos_.Mutable(index);
}
inline ::pb::Histo* SearchResult::add_histos() {
  return histos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Histo >&
SearchResult::histos() const {
  return histos_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Histo >*
SearchResult::mutable_histos() {
  return &histos_;
}

// repeated string fields = 6;
inline int SearchResult::fields_size() const {
  return fields_.size();
}
inline void SearchResult::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& SearchResult::fields(int index) const {
  return fields_.Get(index);
}
inline ::std::string* SearchResult::mutable_fields(int index) {
  return fields_.Mutable(index);
}
inline void SearchResult::set_fields(int index, const ::std::string& value) {
  fields_.Mutable(index)->assign(value);
}
inline void SearchResult::set_fields(int index, const char* value) {
  fields_.Mutable(index)->assign(value);
}
inline void SearchResult::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchResult::add_fields() {
  return fields_.Add();
}
inline void SearchResult::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
}
inline void SearchResult::add_fields(const char* value) {
  fields_.Add()->assign(value);
}
inline void SearchResult::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SearchResult::fields() const {
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SearchResult::mutable_fields() {
  return &fields_;
}

// repeated .pb.Document documents = 7;
inline int SearchResult::documents_size() const {
  return documents_.size();
}
inline void SearchResult::clear_documents() {
  documents_.Clear();
}
inline const ::pb::Document& SearchResult::documents(int index) const {
  return documents_.Get(index);
}
inline ::pb::Document* SearchResult::mutable_documents(int index) {
  return documents_.Mutable(index);
}
inline ::pb::Document* SearchResult::add_documents() {
  return documents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Document >&
SearchResult::documents() const {
  return documents_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Document >*
SearchResult::mutable_documents() {
  return &documents_;
}

// -------------------------------------------------------------------

// Histo_Pair

// required .pb.Value key = 1;
inline bool Histo_Pair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Histo_Pair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Histo_Pair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Histo_Pair::clear_key() {
  if (key_ != NULL) key_->::pb::Value::Clear();
  clear_has_key();
}
inline const ::pb::Value& Histo_Pair::key() const {
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::pb::Value* Histo_Pair::mutable_key() {
  set_has_key();
  if (key_ == NULL) key_ = new ::pb::Value;
  return key_;
}
inline ::pb::Value* Histo_Pair::release_key() {
  clear_has_key();
  ::pb::Value* temp = key_;
  key_ = NULL;
  return temp;
}

// required int32 count = 2;
inline bool Histo_Pair::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Histo_Pair::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Histo_Pair::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Histo_Pair::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 Histo_Pair::count() const {
  return count_;
}
inline void Histo_Pair::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// Histo

// required string field = 1;
inline bool Histo::has_field() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Histo::set_has_field() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Histo::clear_has_field() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Histo::clear_field() {
  if (field_ != &::google::protobuf::internal::kEmptyString) {
    field_->clear();
  }
  clear_has_field();
}
inline const ::std::string& Histo::field() const {
  return *field_;
}
inline void Histo::set_field(const ::std::string& value) {
  set_has_field();
  if (field_ == &::google::protobuf::internal::kEmptyString) {
    field_ = new ::std::string;
  }
  field_->assign(value);
}
inline void Histo::set_field(const char* value) {
  set_has_field();
  if (field_ == &::google::protobuf::internal::kEmptyString) {
    field_ = new ::std::string;
  }
  field_->assign(value);
}
inline void Histo::set_field(const char* value, size_t size) {
  set_has_field();
  if (field_ == &::google::protobuf::internal::kEmptyString) {
    field_ = new ::std::string;
  }
  field_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Histo::mutable_field() {
  set_has_field();
  if (field_ == &::google::protobuf::internal::kEmptyString) {
    field_ = new ::std::string;
  }
  return field_;
}
inline ::std::string* Histo::release_field() {
  clear_has_field();
  if (field_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = field_;
    field_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 count = 2;
inline bool Histo::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Histo::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Histo::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Histo::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 Histo::count() const {
  return count_;
}
inline void Histo::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// repeated .pb.Histo.Pair pairs = 3;
inline int Histo::pairs_size() const {
  return pairs_.size();
}
inline void Histo::clear_pairs() {
  pairs_.Clear();
}
inline const ::pb::Histo_Pair& Histo::pairs(int index) const {
  return pairs_.Get(index);
}
inline ::pb::Histo_Pair* Histo::mutable_pairs(int index) {
  return pairs_.Mutable(index);
}
inline ::pb::Histo_Pair* Histo::add_pairs() {
  return pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Histo_Pair >&
Histo::pairs() const {
  return pairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Histo_Pair >*
Histo::mutable_pairs() {
  return &pairs_;
}

// -------------------------------------------------------------------

// GeoLoc

// required float lng = 1;
inline bool GeoLoc::has_lng() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeoLoc::set_has_lng() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeoLoc::clear_has_lng() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeoLoc::clear_lng() {
  lng_ = 0;
  clear_has_lng();
}
inline float GeoLoc::lng() const {
  return lng_;
}
inline void GeoLoc::set_lng(float value) {
  set_has_lng();
  lng_ = value;
}

// required float lat = 2;
inline bool GeoLoc::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeoLoc::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeoLoc::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeoLoc::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float GeoLoc::lat() const {
  return lat_;
}
inline void GeoLoc::set_lat(float value) {
  set_has_lat();
  lat_ = value;
}

// -------------------------------------------------------------------

// Value

// required .pb.Value.Type type = 1;
inline bool Value::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pb::Value_Type Value::type() const {
  return static_cast< ::pb::Value_Type >(type_);
}
inline void Value::set_type(::pb::Value_Type value) {
  GOOGLE_DCHECK(::pb::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string svalue = 2;
inline bool Value::has_svalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value::set_has_svalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value::clear_has_svalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value::clear_svalue() {
  if (svalue_ != &::google::protobuf::internal::kEmptyString) {
    svalue_->clear();
  }
  clear_has_svalue();
}
inline const ::std::string& Value::svalue() const {
  return *svalue_;
}
inline void Value::set_svalue(const ::std::string& value) {
  set_has_svalue();
  if (svalue_ == &::google::protobuf::internal::kEmptyString) {
    svalue_ = new ::std::string;
  }
  svalue_->assign(value);
}
inline void Value::set_svalue(const char* value) {
  set_has_svalue();
  if (svalue_ == &::google::protobuf::internal::kEmptyString) {
    svalue_ = new ::std::string;
  }
  svalue_->assign(value);
}
inline void Value::set_svalue(const char* value, size_t size) {
  set_has_svalue();
  if (svalue_ == &::google::protobuf::internal::kEmptyString) {
    svalue_ = new ::std::string;
  }
  svalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Value::mutable_svalue() {
  set_has_svalue();
  if (svalue_ == &::google::protobuf::internal::kEmptyString) {
    svalue_ = new ::std::string;
  }
  return svalue_;
}
inline ::std::string* Value::release_svalue() {
  clear_has_svalue();
  if (svalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = svalue_;
    svalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 ivalue = 3;
inline bool Value::has_ivalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Value::set_has_ivalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Value::clear_has_ivalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Value::clear_ivalue() {
  ivalue_ = GOOGLE_LONGLONG(0);
  clear_has_ivalue();
}
inline ::google::protobuf::int64 Value::ivalue() const {
  return ivalue_;
}
inline void Value::set_ivalue(::google::protobuf::int64 value) {
  set_has_ivalue();
  ivalue_ = value;
}

// optional double dvalue = 4;
inline bool Value::has_dvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Value::set_has_dvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Value::clear_has_dvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Value::clear_dvalue() {
  dvalue_ = 0;
  clear_has_dvalue();
}
inline double Value::dvalue() const {
  return dvalue_;
}
inline void Value::set_dvalue(double value) {
  set_has_dvalue();
  dvalue_ = value;
}

// optional .pb.GeoLoc geoloc = 5;
inline bool Value::has_geoloc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Value::set_has_geoloc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Value::clear_has_geoloc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Value::clear_geoloc() {
  if (geoloc_ != NULL) geoloc_->::pb::GeoLoc::Clear();
  clear_has_geoloc();
}
inline const ::pb::GeoLoc& Value::geoloc() const {
  return geoloc_ != NULL ? *geoloc_ : *default_instance_->geoloc_;
}
inline ::pb::GeoLoc* Value::mutable_geoloc() {
  set_has_geoloc();
  if (geoloc_ == NULL) geoloc_ = new ::pb::GeoLoc;
  return geoloc_;
}
inline ::pb::GeoLoc* Value::release_geoloc() {
  clear_has_geoloc();
  ::pb::GeoLoc* temp = geoloc_;
  geoloc_ = NULL;
  return temp;
}

// repeated int64 ivalues = 6;
inline int Value::ivalues_size() const {
  return ivalues_.size();
}
inline void Value::clear_ivalues() {
  ivalues_.Clear();
}
inline ::google::protobuf::int64 Value::ivalues(int index) const {
  return ivalues_.Get(index);
}
inline void Value::set_ivalues(int index, ::google::protobuf::int64 value) {
  ivalues_.Set(index, value);
}
inline void Value::add_ivalues(::google::protobuf::int64 value) {
  ivalues_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Value::ivalues() const {
  return ivalues_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Value::mutable_ivalues() {
  return &ivalues_;
}

// repeated double dvalues = 7;
inline int Value::dvalues_size() const {
  return dvalues_.size();
}
inline void Value::clear_dvalues() {
  dvalues_.Clear();
}
inline double Value::dvalues(int index) const {
  return dvalues_.Get(index);
}
inline void Value::set_dvalues(int index, double value) {
  dvalues_.Set(index, value);
}
inline void Value::add_dvalues(double value) {
  dvalues_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Value::dvalues() const {
  return dvalues_;
}
inline ::google::protobuf::RepeatedField< double >*
Value::mutable_dvalues() {
  return &dvalues_;
}

// repeated .pb.GeoLoc geolocs = 8;
inline int Value::geolocs_size() const {
  return geolocs_.size();
}
inline void Value::clear_geolocs() {
  geolocs_.Clear();
}
inline const ::pb::GeoLoc& Value::geolocs(int index) const {
  return geolocs_.Get(index);
}
inline ::pb::GeoLoc* Value::mutable_geolocs(int index) {
  return geolocs_.Mutable(index);
}
inline ::pb::GeoLoc* Value::add_geolocs() {
  return geolocs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::GeoLoc >&
Value::geolocs() const {
  return geolocs_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::GeoLoc >*
Value::mutable_geolocs() {
  return &geolocs_;
}

// -------------------------------------------------------------------

// Document

// repeated .pb.Value values = 1;
inline int Document::values_size() const {
  return values_.size();
}
inline void Document::clear_values() {
  values_.Clear();
}
inline const ::pb::Value& Document::values(int index) const {
  return values_.Get(index);
}
inline ::pb::Value* Document::mutable_values(int index) {
  return values_.Mutable(index);
}
inline ::pb::Value* Document::add_values() {
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Value >&
Document::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Value >*
Document::mutable_values() {
  return &values_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::SearchResult_Status>() {
  return ::pb::SearchResult_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Value_Type>() {
  return ::pb::Value_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_search_5fresult_2eproto__INCLUDED
